name: nixbuild.net Check Runs
description: |
  Evaluate flake installables and schedule asynchronous builds on nixbuild.net,
  automatically creating GitHub Check Runs.
author: Rickard Nilsson

inputs:
  flake:
    type: string
    required: false
    default: '.'
    description: |
      The flake that should be evaluated and built. By default this is `.`,
      which means the flake located in your repository root. But you can
      change this if your `flake.nix` is somewhere else in your repository,
      or if you want to evaluate a flake from some other repository.
      If you want to evaluate a flake in some subdirectory of your
      repository you must prefix that directory with `./`.

  filter_builds:
    type: string
    required: false
    default: '.top_attr == "checks"'
    description: |
      A `jq` boolean expression that decides which builds from `flake.nix`
      to build. See the `jq` documentation for info on how to write boolean
      expressions: https://stedolan.github.io/jq/manual/.

      When evaluating the expression, the following fields will be
      available:

      .top_attr : Either "checks" or "packages"
      .system   : The build's system ("x86_64-linux", "aarch64-linux" etc)
      .attr     : The build's attribute name, as defined in your flake
      .name     : The build's derivation name

  label_builds:
    type: string
    required: false
    default: '"\(.attr) [\(.system)]"'
    description: |
      A `jq` string expression that defines the label of the build. The
      label is visible in the GitHub Actions UI.
      See the `jq` documentation for info on how to write string
      expressions: https://stedolan.github.io/jq/manual/.

      When evaluating the expression, the following fields will be
      available:

      .top_attr : Either "checks" or "packages"
      .system   : The build's system ("x86_64-linux", "aarch64-linux" etc)
      .attr     : The build's attribute name, as defined in your flake
      .name     : The build's derivation name

  pre_evaluation_script:
    type: string
    required: false
    default: ''
    description: |
      Bash script that should be executed before evaluating the flake.

runs:
  using: "composite"
  steps:
    - name: Setup eval store
      shell: bash
      run: |
        : üèÉ Setup eval store

        # TODO We could use a zram-backed filesystem instead,
        # because the eval-store is likely very compressible
        sudo mkdir /run/nix-eval-store
        sudo mount -t tmpfs none /run/nix-eval-store \
          -o uid=1001,gid=1001,size=100%
        {
          echo "NIX_CONFIG<<EOF"
          echo -ne "${NIX_CONFIG+$NIX_CONFIG\n}"
          echo "store = /run/nix-eval-store"
          echo "auto-optimise-store = false"
          echo "fsync-metadata = false"
          echo "EOF"
        } >> "$GITHUB_ENV"
        echo "XDG_CACHE_HOME=/run/nix-eval-store/cache" >> "$GITHUB_ENV"


    - name: Restore nix-eval-store cache
      id: restore-nix-eval-store
      uses: actions/cache/restore@v4
      with:
        path: |
          /run/nix-eval-store/cache
          /run/nix-eval-store/nix/var/nix/db
          /run/nix-eval-store/nix/store
        key: ${{runner.os}}-${{github.job}}-
        restore-keys: ${{runner.os}}-${{github.job}}-


    - name: Pre-evaluation script
      shell: bash
      run: |
        : üèÉ Run pre-evaluation script

        ${{inputs.pre_evaluation_script}}


    - name: Find installables
      shell: bash
      run: |
        : üèÉ Find installables

        set -eo pipefail
        nix_args=()
        nix_version="$(nix --version)"

        # For Nix >= 2.14 we need --all-systems
        if [[ "$nix_version" =~ 2\.1[456789].* ]]; then
          nix_args+=("--all-systems")
        elif [[ "$nix_version" =~ 2\.[23456789].* ]]; then
          nix_args+=("--all-systems")
        fi

        if [ -n "${{inputs.nix_args}}" ]; then
          IFS='\n'
          while read l; do
            readarray -d ' ' -O "${#nix_args[@]}" -t nix_args < <(echo -n "$l")
          done < <(echo "${{inputs.nix_args}}")
        fi

        # Flake eval caching stops working when referring to the flake in the
        # eval store. Look into if this can be fixed, because it would be nice
        # to avoid having the flake change under our feet during the workflow
        # run
        #FLAKE_URL="path:/run/nix-eval-store/$(
        #  nix flake metadata "${{inputs.flake}}" --json | \
        #    jq -r '.locked.dir as $dir | "\(.path)\(if $dir != "" and $dir != null then "/"+$dir else "" end)"'
        #)"
        FLAKE_URL="${{inputs.flake}}"
        echo "FLAKE_URL=$FLAKE_URL" >> "$GITHUB_ENV"

        FLAKE_INSTALLABLES="$(mktemp)"
        echo "FLAKE_INSTALLABLES=$FLAKE_INSTALLABLES" >> "$GITHUB_ENV"
        jq_expr='
          { checks: (.checks // {}), packages: (.packages // {}) } |
          to_entries |
          map(
            .key as $top_attr |
            .value |
            to_entries |
            map(
              .key as $sys |
              .value |
              to_entries |
              map(
                .key as $attr |
                { name: "",
                  description: "",
                  top_attr: $top_attr,
                  system: $sys,
                  attr: $attr
                } + .value
              )
            )
          ) |
          flatten |
          map(select(${{inputs.filter_builds}})) |
          map(. as $x | (${{inputs.label_builds}}) as $l | $x + {label: $l})
        '
        nix flake show "$FLAKE_URL" "${nix_args[@]}" --quiet --json | \
          jq -rc "$jq_expr" > "$FLAKE_INSTALLABLES"

        CACHE_KEY="${{runner.os}}-${{github.job}}-$(
          {
            nix flake metadata "$FLAKE_URL" --json | jq -r .fingerprint
            cat "$FLAKE_INSTALLABLES"
            echo "$nix_version"
          } | md5sum | cut -d' ' -f1
        )"
        echo "CACHE_KEY=$CACHE_KEY" >> "$GITHUB_ENV"


    - name: Evaluate and upload derivations
      shell: bash
      run: |
        : üèÉ Evaluate and upload derivations

        # TODO It seems that even when everything exists remotely, `nix copy`
        # is somewhat slow. This is because Nix has no way of asking for the
        # validity of complete closures. Instead it will assemble the full
        # closure locally, then send over this complete list of paths to the
        # remote. The remote will then send back a list of all paths that are
        # valid in that list. So, if the closure is big (which is common for
        # eg NixOS .drv-closures), and if most or all paths exist remotely then
        # a lot of time is wasted. First assembling the big list locally, then
        # sending it over the network, then receiving a big list back again.
        # Instead, if we had a way to ask if a path and its closure is
        # valid, things would be much faster. We could perhaps add such an
        # operation to nixbuild.net's HTTP API. Then we could first do that
        # request then `nix copy` the paths that lack valid closures remotely.

        jq_expr='map(. as $x | "\(env.FLAKE_URL)#\($x.top_attr).\($x.system).\($x.attr)")|.[]'
        time (jq <"$FLAKE_INSTALLABLES" -r "$jq_expr" | \
          xargs nix copy --derivation --to ssh-ng://nixbuild)


    - name: Create check runs
      shell: bash
      run: |
        : üèÉ Create check runs

        PROCESS_DIR="$(mktemp -d)"
        jq <"$FLAKE_INSTALLABLES" -c '.[]' | \
          xargs -d '\n' -n1 -P4 \
            check-runs/create-process.sh "$PROCESS_DIR"
        jq -s . "$PROCESS_DIR"/*.json


    - name: Collect garbage
      if: always() && steps.restore-nix-eval-store.outputs.cache-matched-key != env.CACHE_KEY
      shell: bash
      run: |
        : üèÉ Collect garbage
        nix store gc


    - name: Save nix-eval-store cache
      id: save-nix-eval-store
      uses: actions/cache/save@v4
      if: always() && steps.restore-nix-eval-store.outputs.cache-matched-key != env.CACHE_KEY
      with:
        path: |
          /run/nix-eval-store/cache
          /run/nix-eval-store/nix/var/nix/db
          /run/nix-eval-store/nix/store
        key: ${{env.CACHE_KEY}}
